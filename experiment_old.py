"""
Handles experiment data

"""
import os
import glob
import math
import numpy as np
import csv
import pandas as pd
import matplotlib.pyplot as plt
from numpy.core.defchararray import split

DEBUG = True
# os.chdir = ('C:/Users/marcg/Documents/GitHub/evoman_framework')


class Experiment:

    """
        Class used to represent the experiment.

        Attributes
        ----------
        generation_fitness : empty array; used to append generated fitness values 
        c_enemy : enemy type (required for boxplots)

        Methods
        -------
        calculate_average_fitness : calculates average fitness
        store_data : store data for current generation 
        save_solution : store data for current solution
        plot_data : takes in values of the current run (e.g. fitness, average_mean, std_dev) & plots the data
    """

    generation_fitness = np.array([])
    solution_data = np.array([])

    def __init__(self, experiment_name):
        # self.c_enemy = c_enemy
        self.experiment_name = experiment_name

    def calculate_average_generation_fitness(self, fitness):
        self.generation_fitness = np.append(self.generation_fitness, np.average(fitness))

    def calculate_average_fitness_total(self):
        pass

    def get_max_fitness(self, fitness):
        return max(fitness)

    def get_min_fitness(self, fitness):
        return min(fitness)

    def get_solution_name(self):
        split_string = self.experiment_name.split('-', 1)
        solution_name = split_string[0]  # solution_1 or solution_2
        return solution_name

    def set_path(self, destination, file_name):
        dir = os.getcwd()
        solution_name = self.get_solution_name()
        folder = solution_name + destination
        dir1 = os.path.join(dir, folder)
        if DEBUG:
            print(f"Directory = {dir1}")
        return dir1 + self.experiment_name + file_name

    def save_solution(self, best_individual, best_individual_fitness):
        """
            Implements the storing of the values of a solution (i.e. the best fitness after a full evolutionary cycle i.e. after n_gen)
            Stores:
                - fitness average over generations (mean)
                - best fitness (max)

        """

        # We want to save best individual and average fitness of EVERY generation

        self.solution_data = np.array([best_individual, best_individual_fitness])

        # self.generation_fitness <-

        # STORE DATA
        destination = "_saved_data\\"
        file_name = '_saved_data.csv'
        path_to_solution = self.set_path(destination, file_name)
        if DEBUG:
            print(f"Path to solution = {path_to_solution}")

        # STORE VALUES IN .CSV
        with open(path_to_solution, mode='w') as solution:
            csv_writer = csv.writer(solution, delimiter=',')
            csv_writer.writerow(self.solution_data)

    def store_data_experiment(self, experiment_name, fitness):
        """
            Implements merging of the .csv files to enable easier plotting/data handling

            Merges the .csv files generated by store_data_generation & save_solution

        """
        file_extension = '.csv'

        pass

    def line_plot_generation(self, experiment_name, gens):
        """"
            Plots the data per generation

            Params
            ------
            n_gen : number of generations
                - hyperparams
            c_gen : current generation
                - i.e. f'gen{current iteration}' becomes label for x axis
            c_mean : mean fitness of current generation
                - c_mean = total_fitness/n_pop
            c_std_dev : standard deviation from the mean of the current generation
                - c_std_dev = np.std(population)
            c_max : max fitness value of current generation
                - c_max = best_fitness
            c_algo : name of current solution
            c_experiment : experiment name
            c_enemy : current enemy type
            (optional) t_mean : total mean of the whole evolutionary cycle (after all generations)
                - t_mean = sum c_mean of all gen
         """

        # GET DATA - assign fitness averages from .csv file to data_points[]
        data_points = np.genfromtxt(experiment_name + '_generation_fitness.csv', delimiter=',')

        # PLOT DATA - generate a line plot with x = generation_list and y = fitness averages
        plt.plot(gens, data_points, label="average fitness per generation")

        # PLOT PARAMS
        xint = range(min(gens), math.ceil(max(gens)) + 1)
        plt.xticks(xint)  # set y-axis to only integer values
        plt.xlabel('generation')
        plt.ylabel('average fitness')

        # display line plot
        plt.show()

    def line_plot_experiment():
        """
            Plots the data of the experiment: average of fitness averages of all generations
            Uses merged .csv generated by store_data_experiment of generation fitness vals

            Datapoints are:
            - x = average fitness value across all generations for a single experimental run
            - y = run

        """
        pass

    def boxplot():
        """
            Implements method to display a boxplot for the average fitness value of a given solution on a given enemy type


            Params
            ------
            solution : name of the solution
            solution_fitness : the average fitness of the solution after 5 runs
            solution_fitness_min : min fitness value (= bottom whisker)
            solution_fitness_max : max fitness value (= top whisker)
        """

        pass
